-- Haskell data types for the abstract syntax.
-- Generated by the BNF converter.

{-# LANGUAGE GeneralizedNewtypeDeriving #-}

module Frontend.Signe.Abs where

import Prelude (Char, Double, Int, Integer, String)
import qualified Prelude as C (Eq, Ord, Show, Read)
import qualified Data.String

newtype Id = Id ((Int, Int), String)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

newtype Scalar = Scalar String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

data Program = Progr [Toplevel]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Toplevel
    = ToplF Id [Pattern] Expr | ToplFT Id [Pattern] Type Expr
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Expr
    = EVar Id
    | ETrue
    | EFalse
    | ETup [Expr]
    | EMul Complex Expr
    | EApp Expr Expr
    | EPlus Expr Expr
    | EIfq Expr Expr Expr
    | EIf Expr Expr Expr
    | ELet [Let] Expr
    | EAbs [Id] Expr
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Let = LLet Pattern Expr
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Complex = CComp Scalar Scalar
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Pattern = PVar Id | PTup Id Id
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Mono = MVar Id | MQubit | MTens Mono Mono | MArrow Mono Mono
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Type = TMono Mono | TPoly [Id] Mono
  deriving (C.Eq, C.Ord, C.Show, C.Read)

qplus :: Expr
qplus = EPlus EFalse ETrue

qminus :: Expr
qminus = emin EFalse ETrue

qimagi :: Expr
qimagi = EMul cjmag ETrue

qimagj :: Expr
qimagj = EMul cnmag EFalse

emin :: Expr -> Expr -> Expr
emin x y = EPlus x (EMul (creal (Scalar "-1")) y)

eifqs :: Expr -> Expr -> Expr -> Expr
eifqs c t f = EIfq c t f

eabss :: [Id] -> Expr -> Expr
eabss x m = EAbs x m

creal :: Scalar -> Complex
creal r = CComp r (Scalar "0")

cimag :: Scalar -> Complex
cimag i = CComp (Scalar "0") i

cnmag :: Complex
cnmag = CComp (Scalar "0") (Scalar "-1")

cjmag :: Complex
cjmag = CComp (Scalar "0") (Scalar "1")

tpolys :: [Id] -> Mono -> Type
tpolys c t = TPoly c t

