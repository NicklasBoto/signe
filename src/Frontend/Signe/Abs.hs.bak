-- File generated by the BNF Converter (bnfc 2.9.3).

{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE PatternSynonyms #-}

-- | The abstract syntax of language Signe.

module Frontend.Signe.Abs where

import Prelude (String)
import qualified Prelude as C
  ( Eq, Ord, Show, Read
  , Int, Maybe(..)
  )
import qualified Data.String

data Program = Progr [Toplevel]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Toplevel
    = ToplF Id [Pattern] Expr | ToplFT Id [Pattern] Type Expr
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Expr
    = EVar Id
    | ETrue
    | EFalse
    | ETup [Expr]
    | EApp Expr Expr
    | ESup Complex Expr SupOp Complex Expr
    | EMul Complex Expr
    | EComp Expr Expr
    | EIfq Expr Expr Expr
    | EIf Expr Expr Expr
    | ELet [Let] Expr
    | EAbs [Id] Expr
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Let = LLet Pattern Expr
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data SupOp = SOPlus | SOMin
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Complex
    = CComp Scalar Scalar
    | CComn Scalar Scalar
    | CPi
    | CE
    | CExp Complex Complex
    | CDiv Complex Complex
    | CMul Complex Complex
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Pattern = Pattern PatternVar | Patterns [PatternVar]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data PatternVar = PVar Id
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Mono
    = MVar Id | MQubit | MUnit | MTens Mono Mono | MArrow Mono Mono
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Type = TMono Mono | TPoly [Id] Mono
  deriving (C.Eq, C.Ord, C.Show, C.Read)

qplus :: Expr
qplus = sunit ETrue SOPlus EFalse

qminus :: Expr
qminus = sunit ETrue SOMin EFalse

qimagi :: Expr
qimagi = EMul cjmag ETrue

qimagj :: Expr
qimagj = EMul cnmag EFalse

edolr :: Expr -> Expr -> Expr
edolr a b = EApp a b

ecomps :: Expr -> Expr -> Expr
ecomps a b = EComp a b

eifqs :: Expr -> Expr -> Expr -> Expr
eifqs c t f = EIfq c t f

eabss :: [Id] -> Expr -> Expr
eabss x m = EAbs x m

sunit :: Expr -> SupOp -> Expr -> Expr
sunit e1 op e2 = ESup (creal (Scalar "0.7071067811865475")) e1 op (creal (Scalar "0.7071067811865475")) e2

creal :: Scalar -> Complex
creal r = CComp r (Scalar "0")

cimag :: Scalar -> Complex
cimag i = CComp (Scalar "0") i

cnmag :: Complex
cnmag = CComp (Scalar "0") (Scalar "-1")

cjmag :: Complex
cjmag = CComp (Scalar "0") (Scalar "1")

cpis :: Complex
cpis = CPi

munits :: Mono
munits = MUnit

tpolys :: [Id] -> Mono -> Type
tpolys c t = TPoly c t

newtype Id = Id ((C.Int, C.Int), String)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

newtype Scalar = Scalar String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

-- | Start position (line, column) of something.

type BNFC'Position = C.Maybe (C.Int, C.Int)

pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'NoPosition = C.Nothing

pattern BNFC'Position :: C.Int -> C.Int -> BNFC'Position
pattern BNFC'Position line col = C.Just (line, col)

-- | Get the start position of something.

class HasPosition a where
  hasPosition :: a -> BNFC'Position

instance HasPosition Id where
  hasPosition (Id (p, _)) = C.Just p

