-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Frontend.Signe.Par
  ( happyError
  , myLexer
  , pProgram
  , pListToplevel
  , pToplevel
  , pListPattern
  , pExpr3
  , pExpr2
  , pExpr1
  , pExpr
  , pListExpr
  , pLet
  , pListLet
  , pComplex
  , pPattern
  , pMono2
  , pMono1
  , pMono
  , pType
  , pListId
  ) where
import qualified Frontend.Signe.Abs
import Frontend.Signe.Lex
}

%name pProgram Program
%name pListToplevel ListToplevel
%name pToplevel Toplevel
%name pListPattern ListPattern
%name pExpr3 Expr3
%name pExpr2 Expr2
%name pExpr1 Expr1
%name pExpr Expr
%name pListExpr ListExpr
%name pLet Let
%name pListLet ListLet
%name pComplex Complex
%name pPattern Pattern
%name pMono2 Mono2
%name pMono1 Mono1
%name pMono Mono
%name pType Type
%name pListId ListId
-- no lexer declaration
%monad { Either String } { (>>=) } { return }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '*' { PT _ (TS _ 3) }
  '+' { PT _ (TS _ 4) }
  ',' { PT _ (TS _ 5) }
  '-' { PT _ (TS _ 6) }
  '->' { PT _ (TS _ 7) }
  '-j' { PT _ (TS _ 8) }
  '.' { PT _ (TS _ 9) }
  ':' { PT _ (TS _ 10) }
  ':=' { PT _ (TS _ 11) }
  ';' { PT _ (TS _ 12) }
  '=' { PT _ (TS _ 13) }
  '\\' { PT _ (TS _ 14) }
  'else' { PT _ (TS _ 15) }
  'forall' { PT _ (TS _ 16) }
  'if' { PT _ (TS _ 17) }
  'if*' { PT _ (TS _ 18) }
  'if°' { PT _ (TS _ 19) }
  'in' { PT _ (TS _ 20) }
  'j' { PT _ (TS _ 21) }
  'let' { PT _ (TS _ 22) }
  'qubit' { PT _ (TS _ 23) }
  'then' { PT _ (TS _ 24) }
  '{' { PT _ (TS _ 25) }
  '}' { PT _ (TS _ 26) }
  '~+' { PT _ (TS _ 27) }
  '~-' { PT _ (TS _ 28) }
  '~0' { PT _ (TS _ 29) }
  '~1' { PT _ (TS _ 30) }
  '~i' { PT _ (TS _ 31) }
  '~j' { PT _ (TS _ 32) }
  'λ' { PT _ (TS _ 33) }
  '∀' { PT _ (TS _ 34) }
  L_Id { PT _ (T_Id _) }
  L_Scalar { PT _ (T_Scalar $$) }

%%

Id :: { Frontend.Signe.Abs.Id}
Id  : L_Id { Frontend.Signe.Abs.Id (mkPosToken $1) }

Scalar :: { Frontend.Signe.Abs.Scalar}
Scalar  : L_Scalar { Frontend.Signe.Abs.Scalar $1 }

Program :: { Frontend.Signe.Abs.Program }
Program : ListToplevel { Frontend.Signe.Abs.Progr $1 }

ListToplevel :: { [Frontend.Signe.Abs.Toplevel] }
ListToplevel : {- empty -} { [] }
             | Toplevel ';' ListToplevel { (:) $1 $3 }

Toplevel :: { Frontend.Signe.Abs.Toplevel }
Toplevel : Id ListPattern ':=' Expr { Frontend.Signe.Abs.ToplF $1 $2 $4 }
         | Id ListPattern ':' Type ':=' Expr { Frontend.Signe.Abs.ToplFT $1 $2 $4 $6 }

ListPattern :: { [Frontend.Signe.Abs.Pattern] }
ListPattern : {- empty -} { [] }
            | Pattern ListPattern { (:) $1 $2 }

Expr3 :: { Frontend.Signe.Abs.Expr }
Expr3 : Id { Frontend.Signe.Abs.EVar $1 }
      | '~1' { Frontend.Signe.Abs.ETrue }
      | '~0' { Frontend.Signe.Abs.EFalse }
      | '~+' { Frontend.Signe.Abs.qplus }
      | '~-' { Frontend.Signe.Abs.qminus }
      | '~i' { Frontend.Signe.Abs.qimagi }
      | '~j' { Frontend.Signe.Abs.qimagj }
      | '(' ListExpr ')' { Frontend.Signe.Abs.ETup $2 }
      | Complex '*' Expr3 { Frontend.Signe.Abs.EMul $1 $3 }
      | '(' Expr ')' { $2 }

Expr2 :: { Frontend.Signe.Abs.Expr }
Expr2 : Expr2 Expr3 { Frontend.Signe.Abs.EApp $1 $2 }
      | Expr3 { $1 }

Expr1 :: { Frontend.Signe.Abs.Expr }
Expr1 : Expr2 '+' Expr1 { Frontend.Signe.Abs.EPlus $1 $3 }
      | Expr2 '-' Expr1 { Frontend.Signe.Abs.emin $1 $3 }
      | 'if°' Expr 'then' Expr 'else' Expr { Frontend.Signe.Abs.EIfq $2 $4 $6 }
      | 'if*' Expr 'then' Expr 'else' Expr { Frontend.Signe.Abs.eifqs $2 $4 $6 }
      | 'if' Expr 'then' Expr 'else' Expr { Frontend.Signe.Abs.EIf $2 $4 $6 }
      | 'let' '{' ListLet '}' 'in' Expr { Frontend.Signe.Abs.ELet $3 $6 }
      | 'λ' ListId '.' Expr { Frontend.Signe.Abs.EAbs $2 $4 }
      | '\\' ListId '.' Expr { Frontend.Signe.Abs.eabss $2 $4 }
      | Expr2 { $1 }

Expr :: { Frontend.Signe.Abs.Expr }
Expr : Expr1 { $1 }

ListExpr :: { [Frontend.Signe.Abs.Expr] }
ListExpr : {- empty -} { [] }
         | Expr { (:[]) $1 }
         | Expr ',' ListExpr { (:) $1 $3 }

Let :: { Frontend.Signe.Abs.Let }
Let : Pattern '=' Expr { Frontend.Signe.Abs.LLet $1 $3 }

ListLet :: { [Frontend.Signe.Abs.Let] }
ListLet : Let { (:[]) $1 } | Let ';' ListLet { (:) $1 $3 }

Complex :: { Frontend.Signe.Abs.Complex }
Complex : Scalar '+' Scalar 'j' { Frontend.Signe.Abs.CComp $1 $3 }
        | Scalar { Frontend.Signe.Abs.creal $1 }
        | Scalar 'j' { Frontend.Signe.Abs.cimag $1 }
        | '-j' { Frontend.Signe.Abs.cnmag }
        | 'j' { Frontend.Signe.Abs.cjmag }

Pattern :: { Frontend.Signe.Abs.Pattern }
Pattern : Id { Frontend.Signe.Abs.PVar $1 }
        | '(' Id ',' Id ')' { Frontend.Signe.Abs.PTup $2 $4 }

Mono2 :: { Frontend.Signe.Abs.Mono }
Mono2 : Id { Frontend.Signe.Abs.MVar $1 }
      | 'qubit' { Frontend.Signe.Abs.MQubit }
      | '(' Mono ')' { $2 }

Mono1 :: { Frontend.Signe.Abs.Mono }
Mono1 : Mono2 '*' Mono1 { Frontend.Signe.Abs.MTens $1 $3 }
      | Mono2 '->' Mono1 { Frontend.Signe.Abs.MArrow $1 $3 }
      | Mono2 { $1 }

Mono :: { Frontend.Signe.Abs.Mono }
Mono : Mono1 { $1 }

Type :: { Frontend.Signe.Abs.Type }
Type : Mono { Frontend.Signe.Abs.TMono $1 }
     | '∀' ListId '.' Mono { Frontend.Signe.Abs.TPoly $2 $4 }
     | 'forall' ListId '.' Mono { Frontend.Signe.Abs.tpolys $2 $4 }

ListId :: { [Frontend.Signe.Abs.Id] }
ListId : Id { (:[]) $1 } | Id ListId { (:) $1 $2 }
{

happyError :: [Token] -> Either String a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer = tokens
}

